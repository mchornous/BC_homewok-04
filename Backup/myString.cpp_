#include <iostream>
#include <cassert>
#include <cstring>
#include "myString.h"

using namespace std;

myString::myString():buffer(nullptr), size(0), bufferLength(0)
{
}

myString::myString(const myString& s)
{
    try
      {
        buffer = new char[s.size];
      }
    catch (std::bad_alloc& ba)
          {
                std::cerr << "bad_alloc caught: " << ba.what() << '\n';
          }
 //   strcpy(buffer, s);
    size = s.size;

    for(int i = 0; i < size; i++)
    {
      buffer[i] = s.buffer[i];
    }
    buffer[size] = '\n';
}

myString::myString(const char *p)
{
  int i = 0;
  const char * t = p;

  while(*p++)
  {
    i++;
  }
  try
    {
      buffer = new char[i+1];//  + 2
//   	 std::cout << "|||myString|||"<< i << "|||"<< buffer << "|||"<<'\n';
    }
  catch (std::bad_alloc& ba)
        {
              std::cerr << "bad_alloc caught: " << ba.what() << '\n';
        }

  int j = 0;
  for(j;*t;t++,j++)
  {
    buffer[j] = *t;
  }

  buffer[j] = '\0';
  size = j;
  bufferLength = j;
//    	std::cout << j << " |myString|" << bufferLength << "|||||||||||  " << getBuffer() << "|||  " <<'\n';

}

myString::~myString()
{
    delete[] buffer;
}

void myString::clear ()
{
        if ( bufferLength )
                free( buffer );
        init();
}

inline void myString::init()
{
	buffer = NULL;
	bufferLength = size = 0;
}

int myString::length() const
{
    if(buffer == nullptr)
    {
        return 0;
    }
    else
    {
        return size;
    }
}

void myString::resize(size_t newSize )
{
	newSize = newSize > 0 ? newSize : 0;
	buffer = ( char* )realloc( buffer, newSize );
	if ( buffer )
	{
	/*	if ( strLength > newSize )
		{
			strLength = newSize > 0 ? newSize - 1 : 0;
		}
		*/
		buffer[ size ] = 0;
		bufferLength = newSize;
	}
	else
	{
		init();
	}
}
// std::string myString::getBuffer( )// const
// {
// 	string tmp = static_cast<string>(buffer);
// 	//char* tmp = new char [size];
// 	//for(int i = 0; i < size; i++)
// 	//{
// 	//	tmp[i] = buffer[i];
// 	//}

// 	 std::cout << "getBuffer|||"<< size << "|||"<< tmp << "|||"<<'\n';
// 	//tmp[size] = '\n';
// 	return tmp;
// }

char & myString::operator[] (unsigned int x)
{

    return buffer[x];
}

//void myString::operator =(const myString&s)
//{
//    buffer = s.buffer;
//}

// const myString & myString::operator=( const myString & copy )
// {
// 	// Prevent copy to self! if copy itself, do nothing.
// 	if ( &copy != this )
// 	{
// 		size = copy.size;
// 		if ( !bufferLength )
// 		{
// 			bufferLength = size + 1;
// 			//buffer = ( char * ) malloc( bufferLength );
// 			buffer =
// 		}
// 		else if ( bufferLength <= strLength )
// 		{
// 			bufferLength = strLength + 1;
// 			buffer = ( char * ) realloc( buffer, bufferLength );
// 		}
// 		memcpy ( buffer, copy.buffer, strLength + 1 );

// /*
// 		if ( copy.bufferLength > 0 )
// 		{
// 			size_t newlen = copy.strLength + 1;
// 			//char * newstring = (char*)malloc( newlen );
// 			if ( newstring )
// 			{
// 				memcpy ( newstring, copy.buffer, newlen );
// 				bufferLength = newlen;
// 				buffer = newstring;
// 				strLength = copy.strLength;
// 			}
// 		}
// 		*/
// 	}
// 	return *this;
// }

myString & myString::append( const myString& str, size_t len )
{
  char * new_string;
  size_t new_alloc, new_size, size_suffix=0;

  // don't use strlen - it can overrun the len passed in!
  // following codes get the char* length
  const char* p = str.buffer;

  while ( *p && size_suffix < (unsigned)len )
  {
    ++p;
    ++size_suffix;
  }
  if ( !size_suffix)
    return *this;

  new_size = length () + size_suffix + 1;
  // check if we need to expand
  if ( new_size > bufferLength )
  {
    // compute new size
    new_alloc = assign_new_size ( new_size );

    // allocate new buffer
    new_string = (char*) malloc( new_alloc );
    new_string [ 0 ] = 0;

    // copy the previous allocated buffer into this one
    if ( bufferLength && buffer )
      memcpy ( new_string, buffer, length () );

    // append the suffix. It does exist, otherwize we wouldn't be expanding
    memcpy ( new_string + length (), str.buffer, size_suffix );

    // return previsously allocated buffer if any
    if ( bufferLength && buffer )
      free ( buffer );

    // update member variables
    buffer = new_string;
    bufferLength = new_alloc;
  }
  else
  {
    // we know we can safely append the new string
    memcpy ( buffer + length (), str.buffer, size_suffix );
  }
  size = new_size - 1;
  buffer [ size ] = 0;
  return *this;

}

void myString::insert( size_t start, const myString & str, size_t len )
{

//	std::cout << size << " ||||||||||" << bufferLength << "|||||||||||  " << getBuffer() << "|||  " <<'\n';
	if( /*!str || */ len<=0 || start < 0 || start > str.length()  )
		return;
	char* tmp = buffer;
	if( size + len +1 >= bufferLength )
	{
		//resize( size + len + 1);
		char* tmp = new char [ size + len + 1];
	}

	memmove( buffer + start + len, buffer + start, size - start );
//	for(int i = 0; i < size - start; i++ )
//	std::cout << size << " |||||||||" << bufferLength << "||||||||||||  " << getBuffer() << "|||  " <<'\n';
	memmove( buffer + start, str.buffer, len );
	size += len;
	bufferLength = size;
	buffer[size] = '\0';
//	std::cout << size << " ||||||||||" << bufferLength << "|||||||||||  " << getBuffer() << "|||  " <<'\n';
	return;
}

int myString::compare(const myString& right) const
{
  const char* left= buffer;
  return strcmp( left, right.buffer );
}

void myString::swap(myString& strA, myString& strB)
{
	myString tmp(strA);
	strA = strB;
	strB = tmp;
}

// myString myString::substr(/* const string &str,*/ size_t start, size_t len )
// {
// 	/*if( start > str.length() || start < 0 || len < 0 )
// 	{
// 		throw StringIndexOutOfBounds();
// 		return;
// 	}
// 	*/
// 	assert ( start <= length() );
// 	// if given length is overpass the size of string, use the longest substring available.
// 	size_t count = length() - start;
// 	if ( len <= count )
// 	{
// 		count = len;
// 	}
// 	bufferLength = count + 1;
// 	buffer = ( char* ) malloc( bufferLength );
// 	memcpy ( buffer, str.c_str() + start, count );
// 	buffer[ count ] =0;
// 	strLength = count;
// }

int myString::substr(myString& sub_str)
{
	int index =-1;
	int step=0;
	for(int i=0;i< size;i++)
	{
		if(buffer[i] == sub_str[step])
		{
			if(step==0)
			{
		  		index =i;
			}
			step++;
			if(step == sub_str.length())
			{
			  return index;
			}
		}
		else
		{
			step=0;
		}
	}
	return -1;
}

ostream & operator<<(ostream &os, const myString &s)
{
    for(int i = 0; i < s.size; i++)
    {
        os << s.buffer[i];
    }
    return os;

}

bool operator==(const myString & s, const myString & t)
{
    if(s.length() != t.length())
    {
        return false;
    }
    else
    {
        for(int i = 0; i < s.length(); i++)
        {
            if(s.buffer[i] != t.buffer[i])
            {
                return false;
            }
        }
    }
    return true;

}


// int main()
// {
//    myString s1; // s1 == ""
//    assert(s1.length() == 0);

//    myString s2("hi");  // s2 == "hi"
//    assert(s2.length() == 2);

//    myString s3(s2);  // s3 == "hi"
//    assert(s3.length() == 2);

//    assert(s3[0] == 'h');
//    assert(s3[1] == 'i');

//    s1 = s2;  // s1 == "hi"

//    assert(s1 == s2);

//    s3 = "bye";  // s3 == "bye"
//    assert(s3.length() == 3);
//    assert(s3[0] == 'b');
//    assert(s3[1] == 'y');
//    assert(s3[2] == 'e');

//    s1 += "re";  // s1 == "hire"
//    assert(s1 == "hire");

//    s1 += "d"; // s1 == "hired"
//    assert(not (s1 == "hire"));

//    cout << "SUCCESS" << endl;

// }




